<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wowing.github.io</id>
    <title>Arcadia</title>
    <updated>2020-11-21T12:51:42.520Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wowing.github.io"/>
    <link rel="self" href="https://Wowing.github.io/atom.xml"/>
    <subtitle>即使我们手中空无一物</subtitle>
    <logo>https://Wowing.github.io/images/avatar.png</logo>
    <icon>https://Wowing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Arcadia</rights>
    <entry>
        <title type="html"><![CDATA[瑞安市信息学竞赛复赛前练习2 1754 Problem D看比赛 题解]]></title>
        <id>https://Wowing.github.io/post/OrzGoal/</id>
        <link href="https://Wowing.github.io/post/OrzGoal/">
        </link>
        <updated>2020-11-21T12:42:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1>
<p>比赛开始了，KK 准备记录下每一个重要的事件：红黄牌和进球。</p>
<p>假设只有A 队和B队，每队的号码是1~11 号。</p>
<p>进球事件的表示：Goal A 表示A 进球，Goal B 相反</p>
<p>红牌事件：RedCard A 1表示A队1 号被红牌罚下</p>
<p>黄牌事件：YellowCard B 2表示B队2号被黄牌警告<br>
注意，一个人如果被警告两次就将被罚下（相当于一张红牌）。</p>
<p>现在，要输出的是两队的比分、被罚下的名单和被警告的名单。</p>
<h2 id="输入">输入：</h2>
<p>第一行，一个整数n，表示重要事件的个数（n&lt;1000）</p>
<p>之后n 行，每行一个事件，如果第一个词语是Goal，之后输入</p>
<p>进球的编号；如果第一个词语是 RedCard 或YellowCard，那么之后<br>
输入队伍和号码。</p>
<h2 id="输出">输出：</h2>
<p>第一行，格式为A(A 的得分):(B 的得分)B<br>
第二行，输出”SentOff:”</p>
<p>之后若干行，每行一个 A 或B，一个号码，表示被罚下的人，之间用空格隔开，规定先 A 后B，按号码大小排序。</p>
<p>下一行，输出”Warning:”</p>
<p>之后若干行，每行一个 A 或B，一个号码，表示被警告的人，之<br>
间用空格隔开，规定先 A 后B，按号码大小排序。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>8 
Goal A 
RedCard A 4 
Goal B 
YellowCard B 8 
Goal B 
YellowCard B 8 
YellowCard B 10 
Goal B 
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>A(1):(3)B 
SentOff:
A 4 
B 8 
Warning:
B 10 
</code></pre>
<h2 id="提示">提示</h2>
<p>【样例解释1】</p>
<p>B 队进了 3 个球，A 队进了一个。</p>
<p>A 队 4 号被罚下，B 队 8 号累<br>
积两张黄牌下场，</p>
<p>B队的10 号被黄牌警告一次</p>
<h1 id="题解">题解</h1>
<p>首先呢，通过它给我们的样例，可以清楚地看出来这是一道暴力大水题。</p>
<p>可是有一点要注意的是，它的字符串读入是带空格的。在去年上级复赛的时候，就是由于这一点导致我的IDE崩溃</p>
<p><strong>其实使用string+char(+int)就可以了</strong></p>
<p>终于做出了我深恶痛疾的模拟题。然后提醒一下：SentOff和Warning的后面是<strong>没有空格的！！！</strong></p>
<p>好，上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[12],b[12];
int A,B,tt,a1,b1,a2,b2;
string k;
char t;
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;k;
        if(k==&quot;Goal&quot;) 
        {
            cin&gt;&gt;t;//空格会忽略掉
            if(t=='A') A++;
            else B++;
        }
        else
        {
            if(k[0]=='R')
            {
                cin&gt;&gt;t;
                cin&gt;&gt;tt;
                if(t=='A') a[tt]-=2;
                if(t=='B') b[tt]-=2;//大于
            }
            if(k[0]=='Y')
            {
                cin&gt;&gt;t;
                cin&gt;&gt;tt;
                if(t=='A') a[tt]-=1;
                if(t=='B') b[tt]-=1;
            }
        }
    }
    for(int i=1;i&lt;=11;i++) if(a[i]&lt;-2||a[i]==-2) a1++;
    for(int i=1;i&lt;=11;i++) if(b[i]&lt;-2||b[i]==-2) b1++;
    for(int i=1;i&lt;=11;i++) if(a[i]==-1) a2++;
    for(int i=1;i&lt;=11;i++) if(b[i]==-1) b2++;
    cout&lt;&lt;&quot;A(&quot;&lt;&lt;A&lt;&lt;&quot;):&quot;&lt;&lt;&quot;(&quot;&lt;&lt;B&lt;&lt;&quot;)B&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;SentOff:&quot;&lt;&lt;endl;
    if(a1&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(a[i]&lt;-2||a[i]==-2) cout&lt;&lt;&quot;A &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    if(b1&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(b[i]&lt;-2||b[i]==-2) cout&lt;&lt;&quot;B &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    cout&lt;&lt;&quot;Warning:&quot;&lt;&lt;endl;
    if(a2&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(a[i]==-1) cout&lt;&lt;&quot;A &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    if(b2&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(b[i]==-1) cout&lt;&lt;&quot;B &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P1617 【爱与愁的一千个伤心的理由】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-p1617-ai-yu-chou-de-yi-qian-ge-shang-xin-de-li-you/</id>
        <link href="https://Wowing.github.io/post/ti-jie-p1617-ai-yu-chou-de-yi-qian-ge-shang-xin-de-li-you/">
        </link>
        <updated>2020-11-21T12:22:54.000Z</updated>
        <content type="html"><![CDATA[<p>这道题的题目梗概就是：输入一个1~4位的数字，输出它的英文。</p>
<p>我们不妨分类一下：</p>
<p>1位：直接输出</p>
<pre><code>        十几或几十直接输出
</code></pre>
<p>2位：</p>
<pre><code>        否则输出几十+一位
        
        几百直接输出
</code></pre>
<p>3位：</p>
<pre><code>	否则输出几百+两位
    
        几千直接输出
</code></pre>
<p>4位：</p>
<pre><code>	否则输出几千+3位
</code></pre>
<p>另外，只要两个位数间有0,且0的两边不为0，输出“and”</p>
<p><strong>注意：记得特判0的英文zero！！！</strong></p>
<p>所以，可以一个个位数循环。献上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
char a[6];
int l;
int main()
{
	cin&gt;&gt;a;
	l=strlen(a);
	for(int i=0;i&lt;l;i++)
	{
		if(i!=l-2)
		{
		if(a[i]=='0'&amp;&amp;a[i+1]=='0') continue;//如果本身与后一个都为0，直接跳过
		if(a[i]=='0'&amp;&amp;i!=l-1&amp;&amp;a[i+1]!='0') //如果本身是0而下一位不是0才能输出！
		{
			cout&lt;&lt;&quot;and &quot;;
			continue;
		}
		if(a[i]=='1') cout&lt;&lt;&quot;one &quot;;//打表，输出
		if(a[i]=='2') cout&lt;&lt;&quot;two &quot;;
		if(a[i]=='3') cout&lt;&lt;&quot;three &quot;;
		if(a[i]=='4') cout&lt;&lt;&quot;four &quot;;
		if(a[i]=='5') cout&lt;&lt;&quot;five &quot;;
		if(a[i]=='6') cout&lt;&lt;&quot;six &quot;;
		if(a[i]=='7') cout&lt;&lt;&quot;seven &quot;;
		if(a[i]=='8') cout&lt;&lt;&quot;eight &quot;;
		if(a[i]=='9') cout&lt;&lt;&quot;nine &quot;;
		}//这里判断位数
		if(l==4&amp;&amp;i==0) cout&lt;&lt;&quot;thousand &quot;;
		if(l==3&amp;&amp;i==0||l==4&amp;&amp;i==1) cout&lt;&lt;&quot;hundred &quot;;
		if(l==2&amp;&amp;i==0||l==3&amp;&amp;i==1||l==4&amp;&amp;i==2)
		{
			if(a[i]=='0'&amp;&amp;a[i+1]=='0') continue;
			if(a[i]=='0'&amp;&amp;a[i+1]!='0') 
			{
				cout&lt;&lt;&quot;and &quot;;
				continue;
			}
				if(a[i]=='1')
			{
				if(a[i+1]=='0') 
				{
					cout&lt;&lt;&quot;and &quot;;
					continue;
				}//暴力枚举十位（最麻烦的）
				if(a[i+1]=='1') cout&lt;&lt;&quot;eleven &quot;;
				if(a[i+1]=='2') cout&lt;&lt;&quot;twelve &quot;;
				if(a[i+1]=='3') cout&lt;&lt;&quot;thirteen &quot;;
				if(a[i+1]=='4') cout&lt;&lt;&quot;fourteen &quot;;
				if(a[i+1]=='5') cout&lt;&lt;&quot;fifteen &quot;;
				if(a[i+1]=='6') cout&lt;&lt;&quot;sixteen &quot;;
				if(a[i+1]=='7') cout&lt;&lt;&quot;seventeen &quot;;
				if(a[i+1]=='8') cout&lt;&lt;&quot;eighteen &quot;;
				if(a[i+1]=='9') cout&lt;&lt;&quot;nineteen &quot;;
				break;
			}
			if(a[i]=='2') cout&lt;&lt;&quot;twenty &quot;;
			if(a[i]=='3') cout&lt;&lt;&quot;thirty &quot;;
			if(a[i]=='4') cout&lt;&lt;&quot;forty &quot;;
			if(a[i]=='5') cout&lt;&lt;&quot;firty &quot;;
			if(a[i]=='6') cout&lt;&lt;&quot;sixty &quot;;
			if(a[i]=='7') cout&lt;&lt;&quot;seventy &quot;;
			if(a[i]=='8') cout&lt;&lt;&quot;eighty &quot;;
			if(a[i]=='9') cout&lt;&lt;&quot;ninety &quot;;
		}
	}
	if(strcmp(a,&quot;0&quot;)==0) cout&lt;&lt;&quot;zero&quot;;//千万不要忘记特判！
	return 0;
}
</code></pre>
<p>最后补充一句：<code>if(strcmp(a,&quot;0&quot;)==0) cout&lt;&lt;&quot;zero&quot;;</code>也可以写成<code>if(a[0]=='0'&amp;&amp;strlen(a)==1) cout&lt;&lt;&quot;zero&quot;;</code>但由于是char，所以千万不能直接a==&quot;0&quot;!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT957 【何しちゃおっかな？】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at957-he-sitiyaotukana/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at957-he-sitiyaotukana/">
        </link>
        <updated>2020-11-21T12:21:10.000Z</updated>
        <content type="html"><![CDATA[<p><strong>注意：题目中写得为“两种图形各至少一个”！</strong></p>
<p>首先，观察这两种方块，可以非常清楚地发现，如果只用<strong>一种L型</strong>构造，最小的长方形为2*4的矩形。即为：</p>
<p>所以，可以看出来，如果拼成，面积就一定是8的倍数！</p>
<p>然而，还有几个例外：如果一条边为1的话，显然是拼不成的；且2*4的矩形使用的是一种L型，所以也不行！也就是说，只要面积是8的倍数，且a与b的最小公倍数不等于8就可以啦！只要添加这里的判断，恭喜你，可以愉快地AC啦！</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,a,b;
int main()
{
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;a&gt;&gt;b；//防止抄袭
        if(a*b%8!=0||a==1||b==1||a==2&amp;&amp;b==4||a==4&amp;&amp;b==2) cout&lt;&lt;&quot;Impossible&quot;；//防抄++
        else cout&lt;&lt;&quot;Possible&quot;;
        cout&lt;&lt;endl;
    }
    //system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT4142 【[ARC098B] Xor Sum 2】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at4142-arc098b-xor-sum-2/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at4142-arc098b-xor-sum-2/">
        </link>
        <updated>2020-11-21T12:20:33.000Z</updated>
        <content type="html"><![CDATA[<p>一道较简单的题目。</p>
<h3 id="题意">题意</h3>
<p>给你一些数字，求有多少区间的异或和等于区间的数字之和。</p>
<h3 id="题解">题解</h3>
<p>如果直接枚举的话，时间复杂度略高。怎么办呢？可以用两指针，一个指针固定，一个指针滑动。而后，就可以找到最大满足条件的端点了。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=200020;
long long s,n,a[N],ans=0;
int main()
{
	cin&gt;&gt;n;
	//memset(last,0,sizeof(last));
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	long long j=0;
	long long suma=0,sumb=0;
	for(int i=1;i&lt;=n;i++)
	{
		while(j+1&lt;=n&amp;&amp;sumb+a[j+1]==(suma^a[j+1]))//指针滑动
		{
			suma^=a[j+1];
			sumb+=a[j+1];
			j++;
		}
		ans+=j-i+1;
		suma^=a[i];
		sumb-=a[i];
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 UVA1193 【Radar Installation】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-uva1193-radar-installation/</id>
        <link href="https://Wowing.github.io/post/ti-jie-uva1193-radar-installation/">
        </link>
        <updated>2020-11-21T12:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>是一道比较简单的贪心，主要是对公式的运用。</p>
<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你n个坐标上的点, n &lt;= 1000。</p>
<p>你可以在x轴上放置雷达,每个雷达的辐射半径都是d。</p>
<p>现在问你辐射到所有的点至少需要几个雷达,如果辐射不到所有的点输出-1。</p>
<h3 id="题解">题解</h3>
<p>因为二维的贪心比较困难，所以我们使用圆形的公式即可。用公式转化后，就变成了一道覆盖区间的普通贪心。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#define eps 0.0000005
using namespace std;
struct note 
{
	double x;
	double y;
}a[30001];
int n;
double s;
double l,r;
int sum;
bool cmp(note a,note b)
{
	return a.x&lt;b.x;
}
int main()
{
	cin&gt;&gt;n&gt;&gt;s;
	while(n&amp;&amp;s)
	{
		int flag=0;
		for(int i=0;i&lt;n;i++) 
		{
			cin&gt;&gt;l&gt;&gt;r;
			if(abs(r)&gt;s) flag=1;
			a[i].x=l-sqrt(s*s-r*r);
			a[i].y=l+sqrt(s*s-r*r);//公式的运用
		}
		if(flag) //特判
		{
			cout&lt;&lt;&quot;Case &quot;&lt;&lt;++sum&lt;&lt;&quot;: -1&quot;&lt;&lt;endl;
			for(int i=0;i&lt;n;i++) a[i].x=a[i].y=0.0;
			scanf(&quot;\n%d %lf&quot;,&amp;n,&amp;s);
			continue;
		}
		sort(a,a+n,cmp);//开始寻找
		double right=a[0].y;
		int ans=1;
		for(int i=1;i&lt;n;i++)
			if(a[i].x&lt;=right) right=min(right,a[i].y);
			else right=a[i].y,ans++;
		cout&lt;&lt;&quot;Case &quot;&lt;&lt;++sum&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;
		for(int i=0;i&lt;n;i++) a[i].x=a[i].y=0.0;
		scanf(&quot;\n%d %lf&quot;,&amp;n,&amp;s);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF527C 【Glass Carving】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf527c-glass-carving/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf527c-glass-carving/">
        </link>
        <updated>2020-11-21T12:17:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>有一个w*h的矩形,每次要么横着切一刀,要么竖着切一刀,每次你都要回答切完后最大的子矩形的面积。</p>
<p>要么是横着在y位置切一刀,要么是竖着在x位置切一刀.</p>
<h3 id="题解">题解</h3>
<p>原来想着用暴力写，但是数据范围比较大：2 &lt;= w, h &lt;= 200000, 1 &lt;= n &lt;= 200000。然后就想到了STL。</p>
<p>用两个multiset和两个set分别储存切的痕迹与原来的，面积就是最大的长和宽相乘。</p>
<p>代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define its set&lt;int&gt;::iterator
#define is mulitset&lt;int&gt;::iterator

using namespace std;
int w,h,n;
multiset&lt;int&gt; sx;
multiset&lt;int&gt; sy;
set&lt;int&gt; x;
set&lt;int&gt; y;
int main(){

    scanf(&quot;%d%d%d&quot;,&amp;w,&amp;h,&amp;n);
    x.insert(0);
    x.insert(h);
    y.insert(w);
    y.insert(0);
    sx.insert(h);
    sy.insert(w);
    for(int i=1;i&lt;=n;++i)
    {
        char c;
        int p;
        cin&gt;&gt;c;
        scanf(&quot;%d&quot;,&amp;p);

        if(c=='V')
        {
            y.insert(p);
            its it,itt;
            it=y.lower_bound(p);
            itt=y.upper_bound(p);
            --it;

            int ls,rs;
            ls=p-*it;
            rs=*itt-p;
            int ss=*itt-*it;
            //cout&lt;&lt;*itt&lt;&lt;&quot; &quot;&lt;&lt;*it&lt;&lt;&quot; &quot;&lt;&lt;ss&lt;&lt;endl;
            sy.erase(sy.find(ss));
            sy.insert(ls);
            sy.insert(rs);
        }
        else
        {
            x.insert(p);
            its it,itt;
            it=x.lower_bound(p);
            itt=x.upper_bound(p);
            --it;

            int ls,rs;
            ls=p-*it;
            rs=*itt-p;
            int ss=*itt-*it;
            //cout&lt;&lt;*itt&lt;&lt;&quot; &quot;&lt;&lt;*it&lt;&lt;&quot; &quot;&lt;&lt;ss&lt;&lt;endl;
            sx.erase(sx.find(ss));
            sx.insert(rs);
            sx.insert(ls);

        }
        int a,b;
        a=*(--sx.end());
        b=*(--sy.end());
        printf(&quot;%lld\n&quot;,(1LL)*a*b);
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF2B 【The least round way】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf2b-the-least-round-way/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf2b-the-least-round-way/">
        </link>
        <updated>2020-11-21T12:15:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>在一个矩阵中做乘法，让结果的0最少。</p>
<h3 id="题解">题解</h3>
<p>因为是矩阵乘法，0是2与5构成的，只要判断有几个2和5就可以。很容易想到使用dp。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1001;
int x,n;
int dp[N][N][2];
int main()
{
	ios::sync_with_stdio(false);
	cin&gt;&gt;n;
	int pos=-1;
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;x;
			if(x==0)
			{
				pos=i;
				continue;
			}
			int t=x;
			while(t%2==0) 
			{
				dp[i][j][0]++;
				t/=2;	
			}
			t=x;
			while(t%5==0) 
			{
				dp[i][j][1]++;
				t/=5;	
			}
		}
	}
	for(int i=2;i&lt;=n;i++)
	{
		dp[i][1][0]+=dp[i-1][1][0];
		dp[i][1][1]+=dp[i-1][1][1];//初始化
		dp[1][i][0]+=dp[1][i-1][0];
		dp[1][i][1]+=dp[1][i-1][1];
	}	
	for(int i=2;i&lt;=n;i++)
	{
		for(int j=2;j&lt;=n;j++)
		{
			dp[i][j][0]+=min(dp[i-1][j][0],dp[i][j-1][0]);
			dp[i][j][1]+=min(dp[i-1][j][1],dp[i][j-1][1]);
		}//开始dp
	}
	string ans;//string可以更方便操作
	int k=0;
	if(dp[n][n][0]&gt;dp[n][n][1]) k=1;
	if(pos!=-1&amp;&amp;dp[n][n][k]&gt;0)//特判
	{
		cout&lt;&lt;1&lt;&lt;endl;
		for(int i=1;i&lt;pos;i++) cout&lt;&lt;&quot;D&quot;;
		for(int i=1;i&lt;n;i++) cout&lt;&lt;&quot;R&quot;;
		for(int i=pos;i&lt;n;i++) cout&lt;&lt;&quot;D&quot;;
		return 0; 
	}
	int i=n,j=n;
	while(true)
	{
		if(dp[i-1][j][k]&lt;dp[i][j-1][k])
		{
			i--;
			ans+=&quot;D&quot;;
		}
		else
		{
			j--;
			ans+=&quot;R&quot;;
		}
		if(i==1) 
		{
			for(int l=1;l&lt;j;l++) ans+=&quot;R&quot;;
			break; 
		}
		if(j==1)
		{
			for(int l=1;l&lt;i;l++) ans+=&quot;D&quot;;
			break; 
		}
	}
	cout&lt;&lt;dp[n][n][k]&lt;&lt;endl;
	for(int i=ans.size()-1;i&gt;=0;i--) cout&lt;&lt;ans[i];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF543A 【Writing Code】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf543a-writing-code/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf543a-writing-code/">
        </link>
        <updated>2020-11-21T12:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>如果任务的所有书面行最多包含b错误，那么让我们将计划称为好的。你的任务是确定有多少不同的好计划。由于计划的数量可能很大，打印其余的这个数字模给定正整数模。</p>
<h3 id="解析">解析</h3>
<p>比较水的背包，将每一个程序员的代码都看成是不同的物品，求总质量。不过要记得初始化。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1001;
int n,m,b,mod;
int a[N],dp[N][N];
int main()
{
	ios::sync_with_stdio(false);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;b&gt;&gt;mod;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;=b;i++) dp[0][i]=1;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			for(int k=a[i];k&lt;=b;k++)
				dp[j][k]=(dp[j][k]+dp[j-1][k-a[i]])%mod;
	cout&lt;&lt;dp[m][b];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6140 【[USACO07NOV]Best Cow Line S】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/</id>
        <link href="https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/">
        </link>
        <updated>2020-11-21T12:13:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你一个长度为N的字符串S,输入格式是依次输入N个字符。</p>
<p>N &lt;= 2000。</p>
<p>每次你可以从S的开头或者结尾取出一个字符,放到一个T字符串的尾部。</p>
<p>输出字典序最小的T字符串,<strong>每80个字符换一行输出。</strong></p>
<h3 id="题解">题解</h3>
<p>不难，直接循环即可。但是输出略微毒瘤。</p>
<p>我们可以把情况分为两种：</p>
<p>两边字符不一样——直接把字典序小的拿出。</p>
<p>两边字符一样——继续寻找，找到不一样的，然后把字典序小的一边先拿出。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int suml,sumr,sum;
char a[30001],ans[30001];
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	while(strlen(a)!=strlen(ans))
	{
		int l,r;
		r=strlen(a)-1-sumr;
		l=suml;
		while(l&lt;r&amp;&amp;a[l]==a[r]) l++,r--;
		if(a[l]&gt;a[r]) //第一种情况
        sumr++,ans[strlen(ans)]=a[strlen(a)-sumr];
		else suml++,ans[strlen(ans)]=a[suml-1];//否则，判断
	}
	for(int i=0;i&lt;strlen(ans);i++)
	{
		cout&lt;&lt;ans[i];
		sum++;
		if(sum==80) sum=0,cout&lt;&lt;endl;//输出判断
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 SP1684 【FREQUENT - Frequent values】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-sp1684-frequent-frequent-values/</id>
        <link href="https://Wowing.github.io/post/ti-jie-sp1684-frequent-frequent-values/">
        </link>
        <updated>2020-11-21T12:10:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你n个数, 以非递减的顺序给出。</p>
<p>再给你q个询问,</p>
<p>每个询问给你两个数a b。</p>
<p>查询a b区间内的众数的出现次数。</p>
<h3 id="题解">题解</h3>
<p>给大家介绍一种比较简单的方法——使用st表。</p>
<p>st表用于区间最值查询（RMQ），是运用于<strong>静态区间</strong>的求最值。st表的方法非常简单，先预处理然后查询，就好了。其实st表就是一种另类的dp。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,ans;
int a[100001];
int dp[100001][26];
int mp[100001];
void sst()//st表
{
	for(int i=1;i&lt;=n;i++) dp[i][0]=mp[i];
	int dd=(int)(log((double)(n+1))/log(2.0));
	for(int i=1;i&lt;=dd;i++)
		for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)
			dp[j][i]=max(dp[j][i-1],dp[j+(1&lt;&lt;(i-1))][i-1]);
}
int ask(int x,int y)
{
	if(x&gt;y)return 0;
    int k=(int)(log((double)(y-x+1))/log(2.0));
    return max(dp[x][k],dp[y-(1&lt;&lt;k)+1][k]);
}
int main()
{
	ios::sync_with_stdio(false);
	while(1)
	{
		cin&gt;&gt;n;
		if(n==0) return 0;
		cin&gt;&gt;m;
		mp[1]=1;
		for(int i=1;i&lt;=n;i++) 
		{
			cin&gt;&gt;a[i];
			if(i&gt;1) 
			{
				if(a[i]==a[i-1]) mp[i]=mp[i-1]+1;
				else mp[i]=1;
			}
		}
		sst();
		while(m--)
		{
			int x,y;
			cin&gt;&gt;x&gt;&gt;y;
			int now=x;
            while(now&lt;=y&amp;&amp;a[now]==a[now-1])now++;
            cout&lt;&lt;max(now-x,ask(now,y))&lt;&lt;endl;
		} 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>