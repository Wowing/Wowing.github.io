<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wowing.github.io</id>
    <title>Arcadia</title>
    <updated>2020-11-28T12:05:54.298Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wowing.github.io"/>
    <link rel="self" href="https://Wowing.github.io/atom.xml"/>
    <subtitle>即使我们手中空无一物</subtitle>
    <logo>https://Wowing.github.io/images/avatar.png</logo>
    <icon>https://Wowing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Arcadia</rights>
    <entry>
        <title type="html"><![CDATA[关于美化桌面那些事]]></title>
        <id>https://Wowing.github.io/post/guan-yu-mei-hua-zhuo-mian-na-xie-shi/</id>
        <link href="https://Wowing.github.io/post/guan-yu-mei-hua-zhuo-mian-na-xie-shi/">
        </link>
        <updated>2020-11-21T12:56:13.000Z</updated>
        <content type="html"><![CDATA[<p>一个清爽好看的桌面就显得很高逼格的说（</p>
<h1 id="-1我们为什么要美化桌面">-1.我们为什么要美化桌面?</h1>
<ul>
<li>
<p>一个好的桌面能留给人好印象</p>
</li>
<li>
<p>桌面的整洁也能更方便查找</p>
</li>
<li>
<p>美观的桌面看着就舒服</p>
</li>
</ul>
<h1 id="0结果">0.结果</h1>
<p><strong>先给各位看一下我原来的桌面</strong></p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/28/PebiZgkp4TCj7J9.png" alt="zm1.png" loading="lazy"></figure>
<p>显得比较杂乱<s>请无视某些神奇的东西</s></p>
<p><strong>然后就是现在的桌面</strong></p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/11/28/xIaRykQHX9dUJG2.png" alt="image.png" loading="lazy"></figure>
<p>看上去比较清爽</p>
<h1 id="1软件选择">1.软件选择</h1>
<p>由于软件多而杂，这里只放出一部分比较知名的软件</p>
<h2 id="rainmeter">Rainmeter</h2>
<p>大部分的桌面美化者都会选择Rainmeter</p>
<h3 id="优点">优点</h3>
<ul>
<li>
<p>主题多</p>
</li>
<li>
<p>自定义空间大</p>
</li>
<li>
<p>大多主题较酷炫</p>
</li>
<li>
<p>人多</p>
</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>
<p>资源比较杂</p>
</li>
<li>
<p>大部分资源年头较久</p>
</li>
<li>
<p>皮肤代码难上手</p>
</li>
<li>
<p>不能修改系统视觉样式</p>
</li>
</ul>
<h2 id="upupoo">UPUPOO</h2>
<p>啊噗啊噗作为动态壁纸与美化也很不错</p>
<h3 id="优点-2">优点</h3>
<ul>
<li>
<p>壁纸资源多</p>
</li>
<li>
<p>组件好看</p>
</li>
<li>
<p>能美化状态栏</p>
</li>
</ul>
<h3 id="缺点-2">缺点</h3>
<ul>
<li>
<p>单机版不带资源，贴吧资源难找</p>
</li>
<li>
<p>联网软件需要激活码，白嫖党再见</p>
</li>
<li>
<p>功能少</p>
</li>
</ul>
<h2 id="rocketdock">RocketDock</h2>
<p>这是模仿mac的Dock</p>
<h3 id="优点-3">优点</h3>
<ul>
<li>
<p>好用</p>
</li>
<li>
<p>方便</p>
</li>
</ul>
<h3 id="缺点-3">缺点</h3>
<ul>
<li>
<p>自带外貌丑，要去找图标图片替换</p>
</li>
<li>
<p>功能单一</p>
</li>
</ul>
<h2 id="wallpaper-engineer">wallpaper engineer</h2>
<p>这我没钱买不了，只能根据其他人的总结</p>
<h3 id="优点-4">优点</h3>
<ul>
<li>
<p>创意工坊质量高</p>
</li>
<li>
<p>桌面可以互动</p>
</li>
<li>
<p>有趣</p>
</li>
</ul>
<h3 id="缺点-4">缺点</h3>
<ul>
<li>
<p>要钱</p>
</li>
<li>
<p>容易让你沉迷其中无法自拔</p>
</li>
</ul>
<h2 id="live2d-wallpaper">live2d wallpaper</h2>
<p>有趣的live2d互动软件</p>
<h3 id="优点-5">优点</h3>
<ul>
<li>
<p>能和萌妹子互动</p>
</li>
<li>
<p>有趣</p>
</li>
</ul>
<h3 id="缺点-5">缺点</h3>
<ul>
<li>
<p>资源难找</p>
</li>
<li>
<p>功能单一</p>
</li>
</ul>
<h1 id="2正式美化">2.正式美化</h1>
<p>一般来说我们可以把多个软件搭配着用，比如我的桌面就是Rainmeter+UPUPOO+RocketDock，在这里我主要讲Rainmeter</p>
<p>首先，在Rainmeter的官网下载此软件</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/11/28/6Getiw8QF4SOsol.png" alt="zm2.png" loading="lazy"></figure>
<p>这是真正的官网</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/11/28/dUsTfbMvSDzx2ij.png" alt="zm3.png" loading="lazy"></figure>
<p>这是社区</p>
<p><strong>官网下载比较缓慢，而美化社区虽然下载可能快一点但是要钱</strong></p>
<p>下载完成并且安装后你的桌面会出现丑不拉几的这种东西</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/11/28/nB1tqhoGON9YTi6.png" alt="zm4.png" loading="lazy"></figure>
<p>就可以在这个皮肤上鼠标右键</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/11/28/tcAW6LmP7iEjw43.png" alt="zm5.png" loading="lazy"></figure>
<p>选最后一个关闭</p>
<p>接着就可以愉快地下载皮肤了！建议到Rainmeter吧去下载资源。<a href="https://tieba.baidu.com/f?kw=rainmeter">link</a></p>
<p>一般下载完成后，会出现这个东西</p>
<p>!<img src="https://i.loli.net/2020/11/28/Yw1pdbzVrFaeP9v.png" alt="zm7.png" loading="lazy"></p>
<p>双击+Install或右键+用Rainmeter打开即可安装</p>
<p>如果为文件夹类型，需要把文件夹复制到C:\Users\Administrator\Documents\Rainmeter\Skins（你安装的地方）</p>
<p>安装完毕后，就可以使用啦！</p>
<p>打开Rainmeter，在管理器中选择刚刚安装的文件夹并且打开</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/11/28/L1ArKQDHX8UYlv4.png" alt="zm6.png" loading="lazy"></figure>
<p>接着，要找到<strong>ini</strong>文件，双击即可启动皮肤，也可以拖动皮肤</p>
<p>那么Rainmeter大概就讲到这里</p>
<h1 id="3rainmeter资源链接">3.Rainmeter资源链接</h1>
<p><a href="https://zhutix.com/tag/rainmeter/">致美化</a></p>
<p><a href="https://bbs.rainmeter.cn/">雨滴社区（要钱）</a></p>
<p><a href="https://www.zhihu.com/question/41919407">知乎</a></p>
<p><a href="https://tieba.baidu.com/f?kw=rainmeter&amp;ie=utf-8&amp;tab=good">贴吧</a></p>
<h1 id="4结语">4.结语</h1>
<p>非常感谢您的阅读！</p>
<p>桌面美化的方式还有很多，我也不大清楚，如果有不足的地方，还请指出qwq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瑞安市信息学竞赛复赛前练习2 1754 Problem D看比赛 题解]]></title>
        <id>https://Wowing.github.io/post/OrzGoal/</id>
        <link href="https://Wowing.github.io/post/OrzGoal/">
        </link>
        <updated>2020-11-21T12:42:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1>
<p>比赛开始了，KK 准备记录下每一个重要的事件：红黄牌和进球。</p>
<p>假设只有A 队和B队，每队的号码是1~11 号。</p>
<p>进球事件的表示：Goal A 表示A 进球，Goal B 相反</p>
<p>红牌事件：RedCard A 1表示A队1 号被红牌罚下</p>
<p>黄牌事件：YellowCard B 2表示B队2号被黄牌警告<br>
注意，一个人如果被警告两次就将被罚下（相当于一张红牌）。</p>
<p>现在，要输出的是两队的比分、被罚下的名单和被警告的名单。</p>
<h2 id="输入">输入：</h2>
<p>第一行，一个整数n，表示重要事件的个数（n&lt;1000）</p>
<p>之后n 行，每行一个事件，如果第一个词语是Goal，之后输入</p>
<p>进球的编号；如果第一个词语是 RedCard 或YellowCard，那么之后<br>
输入队伍和号码。</p>
<h2 id="输出">输出：</h2>
<p>第一行，格式为A(A 的得分):(B 的得分)B<br>
第二行，输出”SentOff:”</p>
<p>之后若干行，每行一个 A 或B，一个号码，表示被罚下的人，之间用空格隔开，规定先 A 后B，按号码大小排序。</p>
<p>下一行，输出”Warning:”</p>
<p>之后若干行，每行一个 A 或B，一个号码，表示被警告的人，之<br>
间用空格隔开，规定先 A 后B，按号码大小排序。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>8 
Goal A 
RedCard A 4 
Goal B 
YellowCard B 8 
Goal B 
YellowCard B 8 
YellowCard B 10 
Goal B 
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>A(1):(3)B 
SentOff:
A 4 
B 8 
Warning:
B 10 
</code></pre>
<h2 id="提示">提示</h2>
<p>【样例解释1】</p>
<p>B 队进了 3 个球，A 队进了一个。</p>
<p>A 队 4 号被罚下，B 队 8 号累<br>
积两张黄牌下场，</p>
<p>B队的10 号被黄牌警告一次</p>
<h1 id="题解">题解</h1>
<p>首先呢，通过它给我们的样例，可以清楚地看出来这是一道暴力大水题。</p>
<p>可是有一点要注意的是，它的字符串读入是带空格的。在去年上级复赛的时候，就是由于这一点导致我的IDE崩溃</p>
<p><strong>其实使用string+char(+int)就可以了</strong></p>
<p>终于做出了我深恶痛疾的模拟题。然后提醒一下：SentOff和Warning的后面是<strong>没有空格的！！！</strong></p>
<p>好，上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[12],b[12];
int A,B,tt,a1,b1,a2,b2;
string k;
char t;
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;k;
        if(k==&quot;Goal&quot;) 
        {
            cin&gt;&gt;t;//空格会忽略掉
            if(t=='A') A++;
            else B++;
        }
        else
        {
            if(k[0]=='R')
            {
                cin&gt;&gt;t;
                cin&gt;&gt;tt;
                if(t=='A') a[tt]-=2;
                if(t=='B') b[tt]-=2;//大于
            }
            if(k[0]=='Y')
            {
                cin&gt;&gt;t;
                cin&gt;&gt;tt;
                if(t=='A') a[tt]-=1;
                if(t=='B') b[tt]-=1;
            }
        }
    }
    for(int i=1;i&lt;=11;i++) if(a[i]&lt;-2||a[i]==-2) a1++;
    for(int i=1;i&lt;=11;i++) if(b[i]&lt;-2||b[i]==-2) b1++;
    for(int i=1;i&lt;=11;i++) if(a[i]==-1) a2++;
    for(int i=1;i&lt;=11;i++) if(b[i]==-1) b2++;
    cout&lt;&lt;&quot;A(&quot;&lt;&lt;A&lt;&lt;&quot;):&quot;&lt;&lt;&quot;(&quot;&lt;&lt;B&lt;&lt;&quot;)B&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;SentOff:&quot;&lt;&lt;endl;
    if(a1&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(a[i]&lt;-2||a[i]==-2) cout&lt;&lt;&quot;A &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    if(b1&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(b[i]&lt;-2||b[i]==-2) cout&lt;&lt;&quot;B &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    cout&lt;&lt;&quot;Warning:&quot;&lt;&lt;endl;
    if(a2&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(a[i]==-1) cout&lt;&lt;&quot;A &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    if(b2&gt;0) 
    {
        for(int i=1;i&lt;=11;i++) if(b[i]==-1) cout&lt;&lt;&quot;B &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;endl;
    }
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P1617 【爱与愁的一千个伤心的理由】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-p1617-ai-yu-chou-de-yi-qian-ge-shang-xin-de-li-you/</id>
        <link href="https://Wowing.github.io/post/ti-jie-p1617-ai-yu-chou-de-yi-qian-ge-shang-xin-de-li-you/">
        </link>
        <updated>2020-11-21T12:22:54.000Z</updated>
        <content type="html"><![CDATA[<p>这道题的题目梗概就是：输入一个1~4位的数字，输出它的英文。</p>
<p>我们不妨分类一下：</p>
<p>1位：直接输出</p>
<pre><code>        十几或几十直接输出
</code></pre>
<p>2位：</p>
<pre><code>        否则输出几十+一位
        
        几百直接输出
</code></pre>
<p>3位：</p>
<pre><code>	否则输出几百+两位
    
        几千直接输出
</code></pre>
<p>4位：</p>
<pre><code>	否则输出几千+3位
</code></pre>
<p>另外，只要两个位数间有0,且0的两边不为0，输出“and”</p>
<p><strong>注意：记得特判0的英文zero！！！</strong></p>
<p>所以，可以一个个位数循环。献上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
char a[6];
int l;
int main()
{
	cin&gt;&gt;a;
	l=strlen(a);
	for(int i=0;i&lt;l;i++)
	{
		if(i!=l-2)
		{
		if(a[i]=='0'&amp;&amp;a[i+1]=='0') continue;//如果本身与后一个都为0，直接跳过
		if(a[i]=='0'&amp;&amp;i!=l-1&amp;&amp;a[i+1]!='0') //如果本身是0而下一位不是0才能输出！
		{
			cout&lt;&lt;&quot;and &quot;;
			continue;
		}
		if(a[i]=='1') cout&lt;&lt;&quot;one &quot;;//打表，输出
		if(a[i]=='2') cout&lt;&lt;&quot;two &quot;;
		if(a[i]=='3') cout&lt;&lt;&quot;three &quot;;
		if(a[i]=='4') cout&lt;&lt;&quot;four &quot;;
		if(a[i]=='5') cout&lt;&lt;&quot;five &quot;;
		if(a[i]=='6') cout&lt;&lt;&quot;six &quot;;
		if(a[i]=='7') cout&lt;&lt;&quot;seven &quot;;
		if(a[i]=='8') cout&lt;&lt;&quot;eight &quot;;
		if(a[i]=='9') cout&lt;&lt;&quot;nine &quot;;
		}//这里判断位数
		if(l==4&amp;&amp;i==0) cout&lt;&lt;&quot;thousand &quot;;
		if(l==3&amp;&amp;i==0||l==4&amp;&amp;i==1) cout&lt;&lt;&quot;hundred &quot;;
		if(l==2&amp;&amp;i==0||l==3&amp;&amp;i==1||l==4&amp;&amp;i==2)
		{
			if(a[i]=='0'&amp;&amp;a[i+1]=='0') continue;
			if(a[i]=='0'&amp;&amp;a[i+1]!='0') 
			{
				cout&lt;&lt;&quot;and &quot;;
				continue;
			}
				if(a[i]=='1')
			{
				if(a[i+1]=='0') 
				{
					cout&lt;&lt;&quot;and &quot;;
					continue;
				}//暴力枚举十位（最麻烦的）
				if(a[i+1]=='1') cout&lt;&lt;&quot;eleven &quot;;
				if(a[i+1]=='2') cout&lt;&lt;&quot;twelve &quot;;
				if(a[i+1]=='3') cout&lt;&lt;&quot;thirteen &quot;;
				if(a[i+1]=='4') cout&lt;&lt;&quot;fourteen &quot;;
				if(a[i+1]=='5') cout&lt;&lt;&quot;fifteen &quot;;
				if(a[i+1]=='6') cout&lt;&lt;&quot;sixteen &quot;;
				if(a[i+1]=='7') cout&lt;&lt;&quot;seventeen &quot;;
				if(a[i+1]=='8') cout&lt;&lt;&quot;eighteen &quot;;
				if(a[i+1]=='9') cout&lt;&lt;&quot;nineteen &quot;;
				break;
			}
			if(a[i]=='2') cout&lt;&lt;&quot;twenty &quot;;
			if(a[i]=='3') cout&lt;&lt;&quot;thirty &quot;;
			if(a[i]=='4') cout&lt;&lt;&quot;forty &quot;;
			if(a[i]=='5') cout&lt;&lt;&quot;firty &quot;;
			if(a[i]=='6') cout&lt;&lt;&quot;sixty &quot;;
			if(a[i]=='7') cout&lt;&lt;&quot;seventy &quot;;
			if(a[i]=='8') cout&lt;&lt;&quot;eighty &quot;;
			if(a[i]=='9') cout&lt;&lt;&quot;ninety &quot;;
		}
	}
	if(strcmp(a,&quot;0&quot;)==0) cout&lt;&lt;&quot;zero&quot;;//千万不要忘记特判！
	return 0;
}
</code></pre>
<p>最后补充一句：<code>if(strcmp(a,&quot;0&quot;)==0) cout&lt;&lt;&quot;zero&quot;;</code>也可以写成<code>if(a[0]=='0'&amp;&amp;strlen(a)==1) cout&lt;&lt;&quot;zero&quot;;</code>但由于是char，所以千万不能直接a==&quot;0&quot;!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT957 【何しちゃおっかな？】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at957-he-sitiyaotukana/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at957-he-sitiyaotukana/">
        </link>
        <updated>2020-11-21T12:21:10.000Z</updated>
        <content type="html"><![CDATA[<p><strong>注意：题目中写得为“两种图形各至少一个”！</strong></p>
<p>首先，观察这两种方块，可以非常清楚地发现，如果只用<strong>一种L型</strong>构造，最小的长方形为2*4的矩形。即为：</p>
<p>所以，可以看出来，如果拼成，面积就一定是8的倍数！</p>
<p>然而，还有几个例外：如果一条边为1的话，显然是拼不成的；且2*4的矩形使用的是一种L型，所以也不行！也就是说，只要面积是8的倍数，且a与b的最小公倍数不等于8就可以啦！只要添加这里的判断，恭喜你，可以愉快地AC啦！</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,a,b;
int main()
{
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;a&gt;&gt;b；//防止抄袭
        if(a*b%8!=0||a==1||b==1||a==2&amp;&amp;b==4||a==4&amp;&amp;b==2) cout&lt;&lt;&quot;Impossible&quot;；//防抄++
        else cout&lt;&lt;&quot;Possible&quot;;
        cout&lt;&lt;endl;
    }
    //system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT4142 【[ARC098B] Xor Sum 2】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at4142-arc098b-xor-sum-2/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at4142-arc098b-xor-sum-2/">
        </link>
        <updated>2020-11-21T12:20:33.000Z</updated>
        <content type="html"><![CDATA[<p>一道较简单的题目。</p>
<h3 id="题意">题意</h3>
<p>给你一些数字，求有多少区间的异或和等于区间的数字之和。</p>
<h3 id="题解">题解</h3>
<p>如果直接枚举的话，时间复杂度略高。怎么办呢？可以用两指针，一个指针固定，一个指针滑动。而后，就可以找到最大满足条件的端点了。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=200020;
long long s,n,a[N],ans=0;
int main()
{
	cin&gt;&gt;n;
	//memset(last,0,sizeof(last));
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	long long j=0;
	long long suma=0,sumb=0;
	for(int i=1;i&lt;=n;i++)
	{
		while(j+1&lt;=n&amp;&amp;sumb+a[j+1]==(suma^a[j+1]))//指针滑动
		{
			suma^=a[j+1];
			sumb+=a[j+1];
			j++;
		}
		ans+=j-i+1;
		suma^=a[i];
		sumb-=a[i];
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 UVA1193 【Radar Installation】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-uva1193-radar-installation/</id>
        <link href="https://Wowing.github.io/post/ti-jie-uva1193-radar-installation/">
        </link>
        <updated>2020-11-21T12:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>是一道比较简单的贪心，主要是对公式的运用。</p>
<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你n个坐标上的点, n &lt;= 1000。</p>
<p>你可以在x轴上放置雷达,每个雷达的辐射半径都是d。</p>
<p>现在问你辐射到所有的点至少需要几个雷达,如果辐射不到所有的点输出-1。</p>
<h3 id="题解">题解</h3>
<p>因为二维的贪心比较困难，所以我们使用圆形的公式即可。用公式转化后，就变成了一道覆盖区间的普通贪心。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#define eps 0.0000005
using namespace std;
struct note 
{
	double x;
	double y;
}a[30001];
int n;
double s;
double l,r;
int sum;
bool cmp(note a,note b)
{
	return a.x&lt;b.x;
}
int main()
{
	cin&gt;&gt;n&gt;&gt;s;
	while(n&amp;&amp;s)
	{
		int flag=0;
		for(int i=0;i&lt;n;i++) 
		{
			cin&gt;&gt;l&gt;&gt;r;
			if(abs(r)&gt;s) flag=1;
			a[i].x=l-sqrt(s*s-r*r);
			a[i].y=l+sqrt(s*s-r*r);//公式的运用
		}
		if(flag) //特判
		{
			cout&lt;&lt;&quot;Case &quot;&lt;&lt;++sum&lt;&lt;&quot;: -1&quot;&lt;&lt;endl;
			for(int i=0;i&lt;n;i++) a[i].x=a[i].y=0.0;
			scanf(&quot;\n%d %lf&quot;,&amp;n,&amp;s);
			continue;
		}
		sort(a,a+n,cmp);//开始寻找
		double right=a[0].y;
		int ans=1;
		for(int i=1;i&lt;n;i++)
			if(a[i].x&lt;=right) right=min(right,a[i].y);
			else right=a[i].y,ans++;
		cout&lt;&lt;&quot;Case &quot;&lt;&lt;++sum&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;
		for(int i=0;i&lt;n;i++) a[i].x=a[i].y=0.0;
		scanf(&quot;\n%d %lf&quot;,&amp;n,&amp;s);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF527C 【Glass Carving】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf527c-glass-carving/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf527c-glass-carving/">
        </link>
        <updated>2020-11-21T12:17:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>有一个w*h的矩形,每次要么横着切一刀,要么竖着切一刀,每次你都要回答切完后最大的子矩形的面积。</p>
<p>要么是横着在y位置切一刀,要么是竖着在x位置切一刀.</p>
<h3 id="题解">题解</h3>
<p>原来想着用暴力写，但是数据范围比较大：2 &lt;= w, h &lt;= 200000, 1 &lt;= n &lt;= 200000。然后就想到了STL。</p>
<p>用两个multiset和两个set分别储存切的痕迹与原来的，面积就是最大的长和宽相乘。</p>
<p>代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define its set&lt;int&gt;::iterator
#define is mulitset&lt;int&gt;::iterator

using namespace std;
int w,h,n;
multiset&lt;int&gt; sx;
multiset&lt;int&gt; sy;
set&lt;int&gt; x;
set&lt;int&gt; y;
int main(){

    scanf(&quot;%d%d%d&quot;,&amp;w,&amp;h,&amp;n);
    x.insert(0);
    x.insert(h);
    y.insert(w);
    y.insert(0);
    sx.insert(h);
    sy.insert(w);
    for(int i=1;i&lt;=n;++i)
    {
        char c;
        int p;
        cin&gt;&gt;c;
        scanf(&quot;%d&quot;,&amp;p);

        if(c=='V')
        {
            y.insert(p);
            its it,itt;
            it=y.lower_bound(p);
            itt=y.upper_bound(p);
            --it;

            int ls,rs;
            ls=p-*it;
            rs=*itt-p;
            int ss=*itt-*it;
            //cout&lt;&lt;*itt&lt;&lt;&quot; &quot;&lt;&lt;*it&lt;&lt;&quot; &quot;&lt;&lt;ss&lt;&lt;endl;
            sy.erase(sy.find(ss));
            sy.insert(ls);
            sy.insert(rs);
        }
        else
        {
            x.insert(p);
            its it,itt;
            it=x.lower_bound(p);
            itt=x.upper_bound(p);
            --it;

            int ls,rs;
            ls=p-*it;
            rs=*itt-p;
            int ss=*itt-*it;
            //cout&lt;&lt;*itt&lt;&lt;&quot; &quot;&lt;&lt;*it&lt;&lt;&quot; &quot;&lt;&lt;ss&lt;&lt;endl;
            sx.erase(sx.find(ss));
            sx.insert(rs);
            sx.insert(ls);

        }
        int a,b;
        a=*(--sx.end());
        b=*(--sy.end());
        printf(&quot;%lld\n&quot;,(1LL)*a*b);
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF2B 【The least round way】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf2b-the-least-round-way/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf2b-the-least-round-way/">
        </link>
        <updated>2020-11-21T12:15:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>在一个矩阵中做乘法，让结果的0最少。</p>
<h3 id="题解">题解</h3>
<p>因为是矩阵乘法，0是2与5构成的，只要判断有几个2和5就可以。很容易想到使用dp。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1001;
int x,n;
int dp[N][N][2];
int main()
{
	ios::sync_with_stdio(false);
	cin&gt;&gt;n;
	int pos=-1;
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;x;
			if(x==0)
			{
				pos=i;
				continue;
			}
			int t=x;
			while(t%2==0) 
			{
				dp[i][j][0]++;
				t/=2;	
			}
			t=x;
			while(t%5==0) 
			{
				dp[i][j][1]++;
				t/=5;	
			}
		}
	}
	for(int i=2;i&lt;=n;i++)
	{
		dp[i][1][0]+=dp[i-1][1][0];
		dp[i][1][1]+=dp[i-1][1][1];//初始化
		dp[1][i][0]+=dp[1][i-1][0];
		dp[1][i][1]+=dp[1][i-1][1];
	}	
	for(int i=2;i&lt;=n;i++)
	{
		for(int j=2;j&lt;=n;j++)
		{
			dp[i][j][0]+=min(dp[i-1][j][0],dp[i][j-1][0]);
			dp[i][j][1]+=min(dp[i-1][j][1],dp[i][j-1][1]);
		}//开始dp
	}
	string ans;//string可以更方便操作
	int k=0;
	if(dp[n][n][0]&gt;dp[n][n][1]) k=1;
	if(pos!=-1&amp;&amp;dp[n][n][k]&gt;0)//特判
	{
		cout&lt;&lt;1&lt;&lt;endl;
		for(int i=1;i&lt;pos;i++) cout&lt;&lt;&quot;D&quot;;
		for(int i=1;i&lt;n;i++) cout&lt;&lt;&quot;R&quot;;
		for(int i=pos;i&lt;n;i++) cout&lt;&lt;&quot;D&quot;;
		return 0; 
	}
	int i=n,j=n;
	while(true)
	{
		if(dp[i-1][j][k]&lt;dp[i][j-1][k])
		{
			i--;
			ans+=&quot;D&quot;;
		}
		else
		{
			j--;
			ans+=&quot;R&quot;;
		}
		if(i==1) 
		{
			for(int l=1;l&lt;j;l++) ans+=&quot;R&quot;;
			break; 
		}
		if(j==1)
		{
			for(int l=1;l&lt;i;l++) ans+=&quot;D&quot;;
			break; 
		}
	}
	cout&lt;&lt;dp[n][n][k]&lt;&lt;endl;
	for(int i=ans.size()-1;i&gt;=0;i--) cout&lt;&lt;ans[i];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF543A 【Writing Code】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf543a-writing-code/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf543a-writing-code/">
        </link>
        <updated>2020-11-21T12:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>如果任务的所有书面行最多包含b错误，那么让我们将计划称为好的。你的任务是确定有多少不同的好计划。由于计划的数量可能很大，打印其余的这个数字模给定正整数模。</p>
<h3 id="解析">解析</h3>
<p>比较水的背包，将每一个程序员的代码都看成是不同的物品，求总质量。不过要记得初始化。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1001;
int n,m,b,mod;
int a[N],dp[N][N];
int main()
{
	ios::sync_with_stdio(false);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;b&gt;&gt;mod;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;=b;i++) dp[0][i]=1;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			for(int k=a[i];k&lt;=b;k++)
				dp[j][k]=(dp[j][k]+dp[j-1][k-a[i]])%mod;
	cout&lt;&lt;dp[m][b];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6140 【[USACO07NOV]Best Cow Line S】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/</id>
        <link href="https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/">
        </link>
        <updated>2020-11-21T12:13:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你一个长度为N的字符串S,输入格式是依次输入N个字符。</p>
<p>N &lt;= 2000。</p>
<p>每次你可以从S的开头或者结尾取出一个字符,放到一个T字符串的尾部。</p>
<p>输出字典序最小的T字符串,<strong>每80个字符换一行输出。</strong></p>
<h3 id="题解">题解</h3>
<p>不难，直接循环即可。但是输出略微毒瘤。</p>
<p>我们可以把情况分为两种：</p>
<p>两边字符不一样——直接把字典序小的拿出。</p>
<p>两边字符一样——继续寻找，找到不一样的，然后把字典序小的一边先拿出。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int suml,sumr,sum;
char a[30001],ans[30001];
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	while(strlen(a)!=strlen(ans))
	{
		int l,r;
		r=strlen(a)-1-sumr;
		l=suml;
		while(l&lt;r&amp;&amp;a[l]==a[r]) l++,r--;
		if(a[l]&gt;a[r]) //第一种情况
        sumr++,ans[strlen(ans)]=a[strlen(a)-sumr];
		else suml++,ans[strlen(ans)]=a[suml-1];//否则，判断
	}
	for(int i=0;i&lt;strlen(ans);i++)
	{
		cout&lt;&lt;ans[i];
		sum++;
		if(sum==80) sum=0,cout&lt;&lt;endl;//输出判断
	}
}
</code></pre>
]]></content>
    </entry>
</feed>