<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Wowing.github.io</id>
    <title>Arcadia</title>
    <updated>2020-11-21T12:15:20.026Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Wowing.github.io"/>
    <link rel="self" href="https://Wowing.github.io/atom.xml"/>
    <subtitle>即使我们手中空无一物</subtitle>
    <logo>https://Wowing.github.io/images/avatar.png</logo>
    <icon>https://Wowing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Arcadia</rights>
    <entry>
        <title type="html"><![CDATA[题解 CF543A 【Writing Code】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf543a-writing-code/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf543a-writing-code/">
        </link>
        <updated>2020-11-21T12:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>如果任务的所有书面行最多包含b错误，那么让我们将计划称为好的。你的任务是确定有多少不同的好计划。由于计划的数量可能很大，打印其余的这个数字模给定正整数模。</p>
<h3 id="解析">解析</h3>
<p>比较水的背包，将每一个程序员的代码都看成是不同的物品，求总质量。不过要记得初始化。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1001;
int n,m,b,mod;
int a[N],dp[N][N];
int main()
{
	ios::sync_with_stdio(false);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;b&gt;&gt;mod;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;=b;i++) dp[0][i]=1;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			for(int k=a[i];k&lt;=b;k++)
				dp[j][k]=(dp[j][k]+dp[j-1][k-a[i]])%mod;
	cout&lt;&lt;dp[m][b];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6140 【[USACO07NOV]Best Cow Line S】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/</id>
        <link href="https://Wowing.github.io/post/ti-jie-p6140-usaco07novbest-cow-line-s/">
        </link>
        <updated>2020-11-21T12:13:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你一个长度为N的字符串S,输入格式是依次输入N个字符。</p>
<p>N &lt;= 2000。</p>
<p>每次你可以从S的开头或者结尾取出一个字符,放到一个T字符串的尾部。</p>
<p>输出字典序最小的T字符串,<strong>每80个字符换一行输出。</strong></p>
<h3 id="题解">题解</h3>
<p>不难，直接循环即可。但是输出略微毒瘤。</p>
<p>我们可以把情况分为两种：</p>
<p>两边字符不一样——直接把字典序小的拿出。</p>
<p>两边字符一样——继续寻找，找到不一样的，然后把字典序小的一边先拿出。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int suml,sumr,sum;
char a[30001],ans[30001];
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	while(strlen(a)!=strlen(ans))
	{
		int l,r;
		r=strlen(a)-1-sumr;
		l=suml;
		while(l&lt;r&amp;&amp;a[l]==a[r]) l++,r--;
		if(a[l]&gt;a[r]) //第一种情况
        sumr++,ans[strlen(ans)]=a[strlen(a)-sumr];
		else suml++,ans[strlen(ans)]=a[suml-1];//否则，判断
	}
	for(int i=0;i&lt;strlen(ans);i++)
	{
		cout&lt;&lt;ans[i];
		sum++;
		if(sum==80) sum=0,cout&lt;&lt;endl;//输出判断
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 SP1684 【FREQUENT - Frequent values】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-sp1684-frequent-frequent-values/</id>
        <link href="https://Wowing.github.io/post/ti-jie-sp1684-frequent-frequent-values/">
        </link>
        <updated>2020-11-21T12:10:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>多组测试数据。</p>
<p>给你n个数, 以非递减的顺序给出。</p>
<p>再给你q个询问,</p>
<p>每个询问给你两个数a b。</p>
<p>查询a b区间内的众数的出现次数。</p>
<h3 id="题解">题解</h3>
<p>给大家介绍一种比较简单的方法——使用st表。</p>
<p>st表用于区间最值查询（RMQ），是运用于<strong>静态区间</strong>的求最值。st表的方法非常简单，先预处理然后查询，就好了。其实st表就是一种另类的dp。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,ans;
int a[100001];
int dp[100001][26];
int mp[100001];
void sst()//st表
{
	for(int i=1;i&lt;=n;i++) dp[i][0]=mp[i];
	int dd=(int)(log((double)(n+1))/log(2.0));
	for(int i=1;i&lt;=dd;i++)
		for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)
			dp[j][i]=max(dp[j][i-1],dp[j+(1&lt;&lt;(i-1))][i-1]);
}
int ask(int x,int y)
{
	if(x&gt;y)return 0;
    int k=(int)(log((double)(y-x+1))/log(2.0));
    return max(dp[x][k],dp[y-(1&lt;&lt;k)+1][k]);
}
int main()
{
	ios::sync_with_stdio(false);
	while(1)
	{
		cin&gt;&gt;n;
		if(n==0) return 0;
		cin&gt;&gt;m;
		mp[1]=1;
		for(int i=1;i&lt;=n;i++) 
		{
			cin&gt;&gt;a[i];
			if(i&gt;1) 
			{
				if(a[i]==a[i-1]) mp[i]=mp[i-1]+1;
				else mp[i]=1;
			}
		}
		sst();
		while(m--)
		{
			int x,y;
			cin&gt;&gt;x&gt;&gt;y;
			int now=x;
            while(now&lt;=y&amp;&amp;a[now]==a[now-1])now++;
            cout&lt;&lt;max(now-x,ask(now,y))&lt;&lt;endl;
		} 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 UVA1723 【Intervals】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-uva1723-intervals/</id>
        <link href="https://Wowing.github.io/post/ti-jie-uva1723-intervals/">
        </link>
        <updated>2020-11-21T12:07:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意</h3>
<p>有n个如下形式的条件:</p>
<p>ai bi ci,表示在区间[ai, bi]内至少要选择ci个整数点。</p>
<p>问你满足n个条件的情况下,最少需要选多少个点?</p>
<h3 id="题解">题解</h3>
<p>就差分约束呗......</p>
<p>何为差分约束:如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统。</p>
<p>由此，可以把它转化为图，跑一波SPFA就完事了。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;iostream&gt;
using namespace std;
struct node
{
    int u,v,w;
    int next;
}wee[500001];
int minnnn=0x7f,maxxxx=-1;//最小和最大
int n,h[500001],cnt;
int u,v,w;
int vis[500001],stackto[500001],qwq[500001];
void add(int u,int v,int w)
{
    wee[++cnt].u=u;
    wee[cnt].v=v;
    wee[cnt].w=w;
    wee[cnt].next=h[u];
    h[u]=cnt;
}
bool spfa()
{
    stack&lt;int&gt;st;
    while(!st.empty()) st.pop();
    memset(stackto,0,sizeof(stackto));
    memset(qwq,0,sizeof(qwq));
    for(int i=minnnn;i&lt;=maxxxx;i++)
        vis[i]=-0x7f;
    st.push(minnnn);
    vis[minnnn]=0;
    stackto[minnnn]=1;
    qwq[minnnn]++;
    while(!st.empty())
    {
        int u=st.top();
        st.pop();
        stackto[u]=0;
        for(int i=h[u];i!=0;i=wee[i].next)
        {
            if(vis[wee[i].v]&lt;vis[u]+wee[i].w)
            {
                vis[wee[i].v]=vis[u]+wee[i].w;
                if(!stackto[wee[i].v])
                {
                    stackto[wee[i].v]=1;
                    st.push(wee[i].v);
                    qwq[wee[i].v]++;
                    if(qwq[wee[i].v]&gt;n)
                        return false;
                }
            }
        }
    }
    return true;
}

int main()
{
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add(u,v+1,w);
        minnnn=min(minnnn,u);
        maxxxx=max(maxxxx,v+1);
    }
    for(int i=minnnn;i&lt;maxxxx;i++)
    {
        add(i,i+1,0);
        add(i+1,i,-1);
    }
    spfa();//万能的spfa
    cout&lt;&lt;vis[maxxxx]-vis[minnnn]&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT3875 【[ARC089A] Traveling】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at3875-arc089a-traveling/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at3875-arc089a-traveling/">
        </link>
        <updated>2020-04-05T11:22:16.000Z</updated>
        <content type="html"><![CDATA[<p>有生之年居然能够入门题WA，果然我太菜了</p>
<p>好，进入正题：</p>
<p>一开始我看到这样的题目，第一反应就是万能的dfs！</p>
<p>思路：搜索路线，由于求最短时间所以可以直接剪枝向左和向上。而求出最短时间比较即可。</p>
<p>代码分数：0</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,a[41][101],t,fl;
int flag=0;
//bool f[41][41];
int minn=1e9;
void dfs(int x,int y,int sum)//dfs
{
    if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return;
    if(x==n&amp;&amp;y==m) minn=min(minn,sum);
    dfs(x+1,y,sum+1);
    dfs(x,y+1,sum+1);
}
int main()
{
	//ios::sync_with_stdio(false);
	int i,j;
	cin&gt;&gt;t;
    while(t--)
    {
        minn=1e9;
        cin&gt;&gt;fl&gt;&gt;n&gt;&gt;m;
        dfs(1,1,0);
        if(minn&gt;fl||minn==0) flag=1;
        //cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;flag&lt;&lt;endl;
        //else cout&lt;&lt;&quot;No&quot;;
        //cout&lt;&lt;endl;
    }
    if(flag) cout&lt;&lt;&quot;No&quot;;
    else cout&lt;&lt;&quot;Yes&quot;;
	//dfs(1,1,a[1][1]);
	//cout&lt;&lt;maxx;
    //system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<p>反思原因：求的是时间t时能否<strong>到达</strong>，而不是在时间t之前能否到达。</p>
<p>所以让我们再回过头来看看这道题，可以明显地发现其实所需时间就是x+y嘛！等等，还没完：时间大小判断了，那怎么知道t的时候到底能不能到达目的地呢？</p>
<p>经过模拟，可以清楚地发现：如果你要在t时间到达的话，最短时间到目的地后，可以<strong>不停地往回走一格再走回来，往回走一格再走回来......</strong></p>
<p>所以，可以发现，只要剩余的时间mod2余数为0的时候，结果就一定能够到达！</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,t,fl;
int flag=0;
//bool f[41][41];
int minn=1e9;
void dfs(int x,int y,int sum)
{
    if(sum&gt;minn) return;
    if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) return;
    if(x==n&amp;&amp;y==m) minn=min(minn,sum);
    dfs(x+1,y,sum+1);
    dfs(x,y+1,sum+1);
}
int main()
{
	//ios::sync_with_stdio(false);
	int i,j;
	cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;fl&gt;&gt;n&gt;&gt;m;
        if(n+m&gt;fl) //时间太短，原地升天
        {
            flag=1;
            break;
        }
        if((fl-n-m)%2==1) //走了不回，原地升天
        {
            flag=1;
            break;//只要不行，直接走也
        }
    }
    if(flag) cout&lt;&lt;&quot;No&quot;;
    else cout&lt;&lt;&quot;Yes&quot;;
	//dfs(1,1,a[1][1]);
	//cout&lt;&lt;maxx;
    //system(&quot;pause&quot;);
	retun 0; //防止抄袭，抵抗之间
}
</code></pre>
<p>完结撒花~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF441A 【Valera and Antique Items】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-cf441a-valera-and-antique-items/</id>
        <link href="https://Wowing.github.io/post/ti-jie-cf441a-valera-and-antique-items/">
        </link>
        <updated>2020-03-05T04:35:18.000Z</updated>
        <content type="html"><![CDATA[<p>RE了好久，结果发现是<code>system(&quot;pause&quot;);</code>的错误。</p>
<p>首先，看到这道题目，可能很多萌新和我一样是一脸茫然的。“这不是背包/动规吗？怎么成入门题了呢？”</p>
<p>先别急，仔细看题目后，我们可以把题目概括成这样：</p>
<p>有n组数，第i个组数有ki个数字。只要你的数字高于第i个数，这一组数字就属于你了。问你能得到几组数字？分别是第几组？</p>
<p>这样就简单很多了吧......</p>
<p>只要这个数组的数有一个小于你的数，就可以把ai标记为1。最后输出ans即可。</p>
<p>上代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,an,x,nx,ans;
int a[51];
int main()
{
    cin&gt;&gt;n&gt;&gt;an;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;nx;//输入个数
        for(int j=1;j&lt;=nx;j++)
        {
            cin&gt;&gt;x;
            if(x&lt;an) a[i]=1;//桶排序
        }
        if(a[i]==1) ans++;//如果有的话，ans++
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++) if(a[i]==1) cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    //system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>值得一提的是：ans是<strong>你得到的数组数量</strong>，而不是你能得到的数字的数量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT3881 【[ARC090A] Candies】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at3881-arc090a-candies/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at3881-arc090a-candies/">
        </link>
        <updated>2020-03-05T02:09:39.000Z</updated>
        <content type="html"><![CDATA[<p>看到dalao们都用DP写这道题，萌新不得不弱弱地发声：“这难道不是一道DFS题吗？”</p>
<p>实际上，我认为这道题目就是赤裸裸的深度优先搜索！唯一要注意的是n为0的时候的特判。</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,a[41][101];
//bool f[41][41];
int maxx;
void dfs(int x,int y,int sum)
{
    if(x&lt;1||x&gt;2||y&lt;1||y&gt;n) return;
    if(x==2&amp;&amp;y==n) maxx=max(maxx,sum);//maxx取最大值
    if(x&lt;2) dfs(x+1,y,sum+a[x+1][y]);//搜索
    dfs(x,y+1,sum+a[x][y+1]);
}
int main()
{
	//ios::sync_with_stdio(false);
	int i,j;
	cin&gt;&gt;n;
	for(i=1;i&lt;=2;i++)
	{
		for(j=1;j&lt;=n;j++)
		{
			cin&gt;&gt;a[i][j];
		}
	}
	dfs(1,1,a[1][1]);
	cout&lt;&lt;maxx;//输出
    //system(&quot;pause&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT3919 【[ABC088B] Card Game for Two】]]></title>
        <id>https://Wowing.github.io/post/ti-jie-at3919-abc088b-card-game-for-two/</id>
        <link href="https://Wowing.github.io/post/ti-jie-at3919-abc088b-card-game-for-two/">
        </link>
        <updated>2020-03-05T02:08:50.000Z</updated>
        <content type="html"><![CDATA[<p>萌新的奇怪思路：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> mod 2=0:每一次都用奇数项减去偶数项，再加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> mod 2=1:由于最后一张卡牌肯定是先手的，所以直接把最后一个数加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</li>
</ul>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[101],n,ans;
int cmp(int a,int b)
{
    return a&gt;b;
}
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    sort(a+1,a+1+n,cmp);
    if(n%2==1)//直接判断
    {
        n-=1;
        ans+=a[n+1];
    }
    for(int i=1;i&lt;=n;i+=2)//两个一起
    {
        ans+=a[i]-a[i+1];
    }
    cout&lt;&lt;ans;
    //system(&quot;pause&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对于我来说，如何更快地A掉题目]]></title>
        <id>https://Wowing.github.io/post/dui-yu-wo-lai-shuo-ru-he-geng-kuai-di-a-diao-ti-mu/</id>
        <link href="https://Wowing.github.io/post/dui-yu-wo-lai-shuo-ru-he-geng-kuai-di-a-diao-ti-mu/">
        </link>
        <updated>2020-03-05T02:08:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="对于我来说如何更快地骗分a掉题目">对于我来说，如何更快地<s>骗分</s>A掉题目</h1>
<p>这是关于一个蒟蒻的经验，请各位多多指教！</p>
<h2 id="1说明">1.说明</h2>
<p>大部分题目都有说明。这里以<a href="https://wzoi.cc/s/1/2464">小X分砖块</a>为例。在提示（说明）中可以看见这样的说明：</p>
<ul>
<li>对于 30%的数据，N=1。</li>
<li>对于 60%的数据，所有 Ki均相等。</li>
<li>对于 100%的数据， 1≤N≤100000， 1≤Ki≤1000000000， 砖的总块数不超过 1000000000。</li>
</ul>
<p>然后，我惊讶地发现：我不会写这道题。于是，说明就有用了！</p>
<ul>
<li>对于 30%的数据，N=1。<br>
在N=1的情况下，说明只有一段，那么就特判输出砖块总数量就可以了。</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-cpp">	if(n==1)
    {
    	int ttt;
        cin&gt;&gt;ans&gt;&gt;ttt;
        printf(&quot;%d&quot;,ans);
        return 0;
    }
    
</code></pre>
<p>然后，就这样，轻松得了30分。<br>
<a href="https://wzoi.cc/solutions/964078">地址</a></p>
<p>虽然没有满分，但是30分总比0分好吧......</p>
<p>总之，数据是个好东西！</p>
<h2 id="2你谷评论区">2.你谷评论区</h2>
<p>在你谷评论区，总能找到一些神奇的东西。如<a href="https://www.luogu.org/problemnew/show/P1547">P1547 Out of Hay</a></p>
<p>在一开始写这题的时候，只是直接用最小生成树的。然而，在习惯性地点开评论区后.......</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/pic/56159.png" alt="RT" loading="lazy"></figure>
<p>然后就把P1111加上了这位dalao的判断，然后完美AC！؏؏☝ᖗ乛◡乛ᖘ☝؏؏</p>
<p><a href="https://www.luogu.org/recordnew/show/17960629">地址</a></p>
<p>总之，评论区会有惊喜！（当然，有直接代码也不能抄哦！）</p>
<h2 id="3打表">3.打表</h2>
<p>这个就不用说了吧.......</p>
<p><a href="https://www.luogu.org/problemnew/show/CF409F">CF409F 000001</a>，自己体会。</p>
<h2 id="小结">小结</h2>
<p>打表加暴力，</p>
<p>骗分过样例。</p>
<p>暴力出奇迹，</p>
<p>打表出省一。</p>
<p>第一次写文章写得不好请多关照！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大事祭]]></title>
        <id>https://Wowing.github.io/post/da-shi-ji/</id>
        <link href="https://Wowing.github.io/post/da-shi-ji/">
        </link>
        <updated>2020-03-04T09:55:52.000Z</updated>
        <content type="html"><![CDATA[<p>2018-03-24 10:13</p>
<p>欢迎注册洛谷。希望洛谷可以给你带来进步。如果有任何疑问可以查看帮助，也可以直接在讨论区发帖。祝你在洛谷coding愉快！</p>
<p>2018-04-07 13:05</p>
<p>成为了小小牛。以后还要继续努力!</p>
<p>2018-07-18 21:58</p>
<p>成为了小小犇。以后还要继续努力!</p>
<p>2018-08-17 08:36</p>
<p>成为了小牛。以后还要继续努力!</p>
<p>2018-09-17 19:32</p>
<p>成为了小犇。以后还要继续努力!</p>
<p>2018-12-31 11:55</p>
<p>成为了中牛。以后还要继续努力!</p>
<p>2019-01-28 11:08</p>
<p>成为了中犇。以后还要继续努力!</p>
<p>2019-01-31 10:11:51</p>
<p>提交200祭（QAQ）</p>
<p>2019-02-15 12:35:14</p>
<h4 id="绿名祭">绿名祭</h4>
<p>2019-03-03 18:44:24</p>
<p>AC70祭</p>
<p>2019-03-06 20:38:41</p>
<h4 id="又掉蓝2333祭">又掉蓝2333祭</h4>
<p>2019-03-08 18:03</p>
<p>成为了大牛。以后还要继续努力!</p>
<p>2019-03-12 19:57:09</p>
<p>AC80祭（QAQ我真是个蒟蒻）</p>
<p>2019-03-31 20:26:11</p>
<p>愚人节比赛爆0祭</p>
<p>AC95祭</p>
<p>2019-04-14 19:28:05</p>
<p>终于，AC100祭！（果然是个蒟蒻）</p>
<p>2019-04-16 19:02:59</p>
<h4 id="我橙名了橙名祭莫名其妙地橙名了">我！！！！！！橙名了！！！！！！！橙名祭！（莫名其妙地橙名了）</h4>
<p>2019-04-30 16:40:04</p>
<h4 id="莫名其妙又蓝了蓝名祭">莫名其妙又蓝了？？？蓝名祭</h4>
<p>2019-06-22 14:34</p>
<p>成为了大犇。以后还要继续努力!</p>
<p>2019-07-09 21:14:11</p>
<p>通过11^2题祭</p>
<p>2019-07-17 16:18:17</p>
<h4 id="wtf绿名祭">WTF绿名祭</h4>
<p>2019-08-14 20:40:47</p>
<h4 id="蓝了蓝名祭一秒钟前还是绿的">蓝了？？？蓝名祭？？？一秒钟前还是绿的</h4>
<p>2020-2-6 10:34:51</p>
<h4 id="人生中的第一道黑题-这里">人生中的第一道黑题！ <a href="https://www.luogu.com.cn/record/30189379">这里！</a></h4>
<p>2020-03-04 16:54:07</p>
<p>题解5篇祭</p>
<p>2020-03-09 00:00:00</p>
<h4 id="理所当然的绿名祭">理所当然的绿名祭</h4>
<p>2020-04-05 18:57:29</p>
<p>AC200祭+提交600祭，wtcl</p>
]]></content>
    </entry>
</feed>